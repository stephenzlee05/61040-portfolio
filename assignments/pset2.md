# Pset 2


## Concept Questions

1. Each context maintains its own set of unique strings. This allows the same nonce to be generated by two different contexts. In the URL shortening app, the context can be a URL base or domain name, such that each base/domain acts as a separate context, so the generator ensures unique nonces for each base. 


2. NonceGeneration stores sets of used strings to enforce the requirement that the returned string must already be in the used set. In an implementation with a counter, the counter for each context can encode the nonce. The string returned will be deterministic from the counter value and guarantees uniqueness. The abstraction function for a context is Used = {encode(i) | 0 \leq i < n}.


3. An advantage of this scheme for the user is that the words are more memorable and easy to share. A disadvantage is that the dictionary of words is limited, leading to a higher chance of conflicts. To modify the concept, extend the state to include a dictionary of available words, and require generate to pick a word from this dictionary that is not already in the used set for the context.

~~~
concept NonceGeneration [Context]
state
    a set of Contexts with
      a used set of Words
    a global dictionary set of Words
actions
    generate (context: Context) : (nonce: Word)
      requires some word in dictionary not in used
      effect returns a word from dictionary not already used by this context
             and adds it to the used set
~~~


## Synchronization Questions


1. In the first sync (generate), only the context shortUrlBase is needed to generate a nonce. In the second sync (register), shortUrlBase and targetUrl are included because the system must associate the generated nonce with both the base and original target.


2. Being explicit avoids collisions and ambiguity when multiple actions involve arguments with the same name. Explicit naming also documents intent and improves readability.


3. The requests action appears in the first two syncs because those synchronizations are directly triggered by a userâ€™s shortenUrl request and need its arguments. The third sync is triggered instead by the completion of UrlShortening.register, once a short URL is registered, the system autonomously enforces the expiration policy. This no longer depends on the user request, so the request action is not included.


4.
~~~
sync generate
  when Request.shortenUrl ()
  then NonceGeneration.generate (context: "bit.ly")


sync register
  when
    Request.shortenUrl (targetUrl)
    NonceGeneration.generate (): (nonce)
  then UrlShortening.register (shortUrlSuffix: nonce, shortUrlBase: "bit.ly", targetUrl)


sync setExpiry
  when UrlShortening.register (): (shortUrl)
  then ExpiringResource.setExpiry (resource: shortUrl, seconds: 3600)
~~~


5.
~~~
sync expire
  when ExpiringResource.expireResource (): (resource: shortUrl)
  then UrlShortening.delete (shortUrl)
~~~


## Extending the design


1.
~~~
concept ProvideAnalytics [ShortUrl]
  purpose maintain usage counts of short URLs
  principle each access increments the stored count for that short URL
  state
    a set of Counts with
      shortUrl String
      count Number
  actions
    increment (shortUrl: String)
      effect increments count for shortUrl, or initializes to 1 if not present
    getCount (shortUrl: String) : (count: Number)
      requires a count exists for shortUrl
      effect returns the current count


concept Ownership [User, ShortUrl]
  purpose restrict analytics visibility to the registering user
  principle only the user who registered a short URL can view its analytics
  state
    a set of Ownerships with
      shortUrl String
      owner User
  actions
    assignOwner (shortUrl: String, user: User)
      requires no owner assigned yet
      effect associates shortUrl with user
    checkOwnership (shortUrl: String, user: User) : (allowed: Boolean)
      effect returns true if and only if user is the owner of shortUrl
~~~


2.
~~~
sync assignOwner
when
  Request.shortenUrl (user, targetUrl, shortUrlBase)
  UrlShortening.register (): (shortUrl)
then Ownership.assignOwner (resource: shortUrl, owner: user)


sync incrementOnLookup
when UrlShortening.lookup (shortUrl)
then ProvideAnalytics.increment (resource: shortUrl)


sync getAnalytics
when
    Request.getAnalytics (shortUrl, requester)
    Ownership.checkOwnership (shortUrl, user) : (allowed)
then ProvideAnalytics.getCount (resource: shortUrl) : (count)
~~~


3.
Allowing users to choose their own URLs:
~~~
concept UrlShortening
  actions
    register (shortUrlSuffix, shortUrlBase, targetUrl: String, customSuffix: String?) : (shortUrl: String)
      requires (customSuffix is null OR no shortening exists for shortUrlBase/customSuffix)
      effect uses customSuffix if provided, otherwise uses shortUrlSuffix


sync register
when
  Request.shortenUrl (targetUrl, shortUrlBase, customSuffix?)
  NonceGeneration.generate (): (nonce)
then UrlShortening.register (shortUrlSuffix: customSuffix ?? nonce, shortUrlBase, targetUrl)
~~~


Using the "word as nonce" strategy to generate more memorable short URLs:
~~~
concept NonceGeneration [Context]
state
    a set of Contexts with
      a used set of Words
      a dictionary set of Words
actions
    generate (context: Context) : (nonce: Word)
      requires some word in dictionary not in used
      effect returns unused word and adds to used set
~~~


Including the target URL in analytics, so that lookups of different short URLs can be grouped together when they refer to the same target URL:
~~~
concept ProvideAnalytics [ShortUrl]
  state
    a set of Counts with
      shortUrl String
      targetUrl String
      count Number
  actions
    increment (shortUrl: String, targetUrl: String)
      effect increments count for shortUrl, or initializes to 1 if not present
             increments count for targetUrl, or initializes to 1 if not present
    getCount (shortUrl: String) : (count: Number)
      requires a count exists for shortUrl
      effect returns the shortUrl count
    getTargetCount (targetUrl: String, requester: User) : (count: Number)
      requires Ownership.checkOwnership for any shortUrl pointing to targetUrl
      effect returns sum of counts for all shortUrls pointing to targetUrl


sync trackTargetOnRegister
when UrlShortening.lookup (shortUrl): (targetUrl)
then ProvideAnalytics.increment (shortUrl, targetUrl)
~~~


Generate short URLs that are not easily guessed:
~~~
concept NonceGeneration [Context]
  actions
    generate (context: Context) : (nonce: String)
      effect returns cryptographically random string not in used set
~~~


Supporting reporting analytics to creators of short URLs who have no registered as user:
Undesirable, would break security model and changes ownership system. It would be better to require user accounts for analytics.

